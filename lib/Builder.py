import sys, os
import re
from glob import glob
#import yaml
import numpy as np
from scipy import io
#import functools
#import IPython as ip
import logging

from msmbuilder.MSMLib import GetCountMatrixFromAssignments
from msmbuilder.MSMLib import EstimateReversibleCountMatrix
from msmbuilder.MSMLib import ErgodicTrim, ApplyMappingToAssignments
from msmbuilder import clustering, metrics
from msmbuilder.Trajectory import Trajectory
from msmbuilder import Serializer
from msmbuilder.assigning import assign_in_memory

class Builder(object):
    """
    The Builder class is responsable for managing the construction of MSMs.
    it takes in the data generated by the QMaster and presents it in a
    comprehensible format to the Brain.
    """
    
    def __init__(self, project):
        self.project = project
        self.logger = logging.getLogger('MSMAccelerator.Builder')

        try:
            self.round_num = max([e['round_num'] for e in self.project.builder_log]) + 1
        except:
            self.logger.info('Builder Round: 0')
            self.round_num = 0
            
        if self.round_num != 0:
            # load up the rounds folder from disk (for the first forcefield),
            # and make sure the latest one matches what's in the log file
            highest_round_on_disk = max([max(r) for r in self.project.rounds_on_disk])
            if not highest_round_on_disk + 1== self.round_num:
                raise ValueError('Log says were at %s, disk says were at %s' % \
                                     (highest_round_on_disk + 1, self.round_num))
    
    def load_trajs(self, ff_name, stride=1):
        """Load all the lh5 trajectories in traj_log that come from this forcefield
        
        Returns two lists, one of the trajectories, and one of their paths"""
        
        trajs = [t for t in self.project.traj_log if t['ff'] == ff_name]
        index_and_path = [(t['lh5_trajnum'], t['lh5_fn']) for t in trajs]
        
        loaded_trajs = [None] * len(trajs)
        sorted_paths = [None] * len(trajs)
        
        for index, path in index_and_path:
            try:
                t = Trajectory.LoadTrajectoryFile(path)
            except Exception as ex:
                a = '\n' + ''.join(['#'] * 80)
                b = a + '\nTrajectory ({path}) could not be loaded from lh5. It may be corrupt'.format(path=path)
                e = b + a
                raise IOError(str(ex) + e)
            loaded_trajs[index] = t[::stride]
            sorted_paths[index] = path
        
        return loaded_trajs, sorted_paths

    def run_round(self, checkdata=True):
        """This is the method that activates the builder, which eventually
        produces all the necessary MSM data for the Brain to make an
        informed decision about what/where to sample.
           
        (1) Checks to see if there is enough data around to warrant building a
            new set of MSMs 
        (2) Assuming yes, builds a new MSM in each FF, and a combined data MSM
        (3) Generates cross-assigned MSMs
        
        Args:    'checkdata' can be used to overrule the checking process
        Returns: True if actually did a round, False otherwise
        """
        
        if checkdata:
            self.logger.info("Checking if sufficient data has been acquired.")
            FF_to_build = self.is_sufficient_new_data()
            if FF_to_build is None:
                self.logger.info("No need to build a new MSM at this point.")
                return False
        else:
            self.logger.info("Skipping check for adequate data. Building MSMs for all forcefields.")
            FF_to_build = self.project.forcefields
                
        for FF in FF_to_build:
            self.logger.info("Building MSM for forcefield: {0}.".format(FF['name']))
            self.build_msm(FF)
        
        self.logger.info("Finished round: %d" % self.round_num)
        self.round_num += 1
        return True
    
    
    def joint_clustering(self):
        """Jointly cluster the the data from all of the forcefields
        
        Returns
        -------
        """
        trajs, paths = self.load_trajs(self.project.joint_ff['name'],
            stride=self.project.stride)
    
    def build_msm(self, ff_dict):
        """Build an MSM according to the user-specified parameters, which are
        passed implicitly via the perviously parsed configuration YAML file.
        FF is the forcefield (a dict) to build the msm for"""
            
        self.logger.info("Building MSM for: %s" % FF['name'])
        
        # load trajectories
        trajs, paths = self.load_trajs(FF['name'], stride=self.project.stride)
        if len(trajs) == 0:
            raise IOError("Could not find any trajectories")
        
        self.logger.debug('Loaded trajectories. Clustering...')
        
        # the clustering algorithms are very verbose
        with open('/dev/null', 'w') as f:
            sys.stdout = f
            clusterer = self.project.clusterer(trajectories=trajs)
            sys.stdout = sys.__stdout__
        
        self.logger.debug('Assigning...')
        
        # assign this data to its generators
        if self.project.stride == 1:
            assignments = clusterer.get_assignments()
        else:
            # load up all the trajectories, no stride
            # note: if we start getting >10gigs of data this is going to be a memory issue,
            #       we could instead load up and cluster the trajs one at a time
            trajs, paths = self.load_trajs(FF['name'], stride=1)
            assignments = clusterer.assign_new_trajectories(trajs)
        
        self.logger.debug('Constructing counts matrix...')

        # Build an MSM
        counts = self.construct_counts_matrix(assignments)
        self.logger.debug('Got counts. Saving to disk...')
        
        # write output to disk
        self.logger.debug('Saving {a}'.format(a=self.project.assignments_fn(FF['name'], self.round_num)))
        Serializer.SaveData(self.project.assignments_fn(FF['name'], self.round_num),
                            assignments)
        io.mmwrite(self.project.counts_fn(FF['name'], self.round_num), counts)
        
        try:
            medoids = clusterer.get_generators_as_traj()
            medoids.SaveToLHDF(self.project.medoids_fn(FF['name'], self.round_num))
        except AttributeError as e:
            self.logger.warning(e.message)
        
        log_entry = {'forcefield': FF,
                     'round_num': self.round_num,
                     'lh5_fns': paths,
                     'total_num_frames': sum([len(t) for t in trajs])}
        self.project.builder_log_add(log_entry)
        
        self.logger.info('Built MSM sucessfully')


    def construct_counts_matrix(self, assignments):
        """Build and return a counts matrix from assignments. Symmetrize either
        with transpose or MLE based on the value of the self.symmetrize variable
        
        Also modifies the assignments file that you pass it to reflect ergodic
        trimming"""
        
        num_states  = np.max(assignments.flatten()) + 1
        raw_counts = GetCountMatrixFromAssignments(assignments, num_states,
                                            LagTime=self.project.lagtime, Slide=True)
        
        ergodic_counts = None
        if self.project.trim:
            try:
                ergodic_counts, mapping = ErgodicTrim(raw_counts)
                ApplyMappingToAssignments(assignments, mapping)
                counts = ergodic_counts
            except Exception as e:
                self.logger.warning("ErgodicTrim failed with message '{0}'".format(e))
        else:
            self.logger.info("Ignoring ergodic trimming")
            counts = raw_counts
        
        if self.project.symmetrize == 'transpose':
            self.logger.debug('Transpose symmetrizing')
            counts = counts + counts.T
        elif self.project.symmetrize == 'mle':
            self.logger.debug('MLE symmetrizing')
            counts = EstimateReversibleCountMatrix(counts)
        elif self.project.symmetrize == 'none' or self.project.symmetrize == None:
            self.logger.debug('Skipping symmetrization')
        else:
            raise ValueError("Could not understand symmetrization method: %s" % self.project.symmetrize)
        
        return counts
    
    
    def is_sufficient_new_data(self):
        """Checks to see if there is enough data to justify building a new
        MSM. Considers each FF individually, and returns a list of the
        strings naming each FF that an MSM should be constructed for.
        
        If there is insufficient data for all MSMs, returns: None """
        
        try:
            latest_round = max([e['round_num'] for e in self.project.builder_log])
            latest = [e for e in self.project.builder_log if e['round_num']  == latest_round]
            # the filenames (lh5s) of the trajectories that were included in
            # the most recent round of MSM building
            built_trajs_fn = [i for sublist in [e['lh5_fns'] for e in latest] for i in sublist]
        except ValueError:
            self.logger.debug('BuilderLog is empty')
            built_trajs_fn = []

        current_trajs = self.project.traj_log
        self.logger.info('{cur} trajectories on disk & {prev} trajectories in last build'.format(cur=len(current_trajs), prev=len(built_trajs_fn)))
        if not (len(current_trajs) >= len(built_trajs_fn) + self.project.num_trajs_sufficient_for_round):
            self.logger.info('(I require >={extra} trajectories to call a new round)'.format(extra=self.project.num_trajs_sufficient_for_round))
            return None
        
        set_of_ff = set()
        diff = set([e['lh5_fn'] for e in current_trajs]) - set(built_trajs_fn)
        for traj_fn in diff:
            traj = [e for e in current_trajs if e['lh5_fn'] == traj_fn][0]
            set_of_ff.add(traj['ff']) # just the name of each ff
        
        # we need to manually add 'AllFF' so that the joint data will get processed as well
        set_of_ff.add('AllFF')
        
        ff_to_build = [] # should be a list of the dicts corresponding to
        # each forcefield, not just the name
        for name in set_of_ff:
            ff_to_build.extend([ff for ff in self.project.forcefields if ff['name'] == name])

        return ff_to_build
    

def test():
    os.system('rm -r /home/rmcgibbo/monakos/robert/project/amber99sb-ildn/round0')
    os.system('rm -r /home/rmcgibbo/monakos/robert/project/AllFF/round0')
    b = Builder('/home/rmcgibbo/monakos/robert/project',
            '/home/rmcgibbo/monakos/robert/MonakosParams.yaml')
            
    b.run_round()
    
if __name__ == '__main__':
    #test()
    pass
    
