import sys, os
import re
import numpy as np
from scipy import io
import logging

# msmbuilder imports
from msmbuilder.MSMLib import GetCountMatrixFromAssignments
from msmbuilder.MSMLib import EstimateReversibleCountMatrix
from msmbuilder.MSMLib import ErgodicTrim, ApplyMappingToAssignments
from msmbuilder import clustering, metrics
import msmbuilder.Trajectory
import msmbuilder.Serializer
from msmbuilder.assigning import assign_in_memory

from models import db, Trajectory, Forcefield, MarkovModel, MSMGroup

class Builder(object):
    """
    The Builder class is responsable for managing the construction of MSMs.
    it takes in the data generated by the QMaster and adds it to the database
    """
    
    def __init__(self, project):
        self.project = project
        self.logger = logging.getLogger('MSMAccelerator.Builder')
    
    
    def is_sufficient_new_data(self):
        """Is there sufficient new data to build a new round?
        
        Returns
        -------
        truth : boolean
            True if there is sufficient new data for a new round
        """
        
        # get most recent set of MSMs built
        msmgroup = db.query(MSMGroup).order_by(MSMGroup.id.desc()).first()
        
        # the number of unique trajectories that are part of this msmgroup
        # by constructing a query for the union of trajectories in any of the msms
        # in the msm group
        q = db.query(Trajectory)
        for msm in msmgroup.markov_models:
            q.union(db.query(Trajectory).filter(Trajectory.markov_models.contains(msm)))
        n_built = q.count()
        
        # number of trajs in the database
        n_total = db.query(Trajectory).count()
        
        truth = n_built + self.project.num_trajs_sufficient_for_round > n_total
        
        self.logger.info("{} trajs total, {} trajs built".format(n_total, n_built))
        return truth
    
    
    def run_round(self, checkdata=True):
        """Activate the builder and build new MSMs (if necessary)
        
        First, check to see if there is enough data are to warrant building a
        new set of MSMs. Assuming yes, do a joint clustering over all of the
        data, and then build MSMs for each forcefield on that state space.
        
        Parameters
        ----------
        checkdata : boolean, optional
            If False, skip the checking process
        
        Returns
        -------
        happened : boolean
            True if we actually did a round of MSM building, False otherwise
        """
        
        if checkdata:
            self.logger.info("Checking if sufficient data has been acquired.")
            if not self.is_sufficient_new_data():
                return False
        
        self.logger.info("Skipping check for adequate data.")
        
        generators = self.joint_clustering()
        
        msmgroup = MSMGroup()
        for db.query(Forcefields).all():
            msm = self.build_msm(forcefield, generators=generators)
            msmgroup.markov_models.append(msm)
        
        return True
        
        
    def joint_clustering(self):
        """Jointly cluster the the data from all of the forcefields
        
        Returns
        -------
        generators : msmbuilder.Trajectory
        """
        self.logger.info('Running joint clustering')
        
        # load up all the trajs in the database
        db_trajs = db.query(Trajectories).all()
        
        # load the xyz coordinates from disk for each trajectory
        loaded_trjs = [t.load_from_lh5(self.project.stride) for q in db_trajs]
        
        clusterer = self.project.clusterer(trajectories=loaded_trjs)
        return clusterer.get_generators_as_traj()

            
    def build_msm(self, forcefield, generators):
        """Build an MSM for this forcefield using the most recent trajectories
        in the database.
        
        If supplied, use the supplied generators
        
        Parameters
        ----------
        forcefield : models.Forcefield
            database entry on the forcefield that we build for
        generators : msmbuilder.Trajectory

        Returns
        -------
        msm : models.MarkovModel
        
        """
        
        # I want to use assign_in_memory, which requires an msmbuilder.Project
        # so, lets spoof it
        class Project(dict):
            def __init__(self):
                self['NumTrajs'] = len(forcefield.trajectories)
                self['TrajLengths'] = np.array([len(t) for t in forcefield.trajectories])
            
            def load_traj(self, trj_index):
                forcefield.trajectories[trj_index].load_from_lh5()
        
        self.project.info('Assigning...')
        assignments, distances = assign_in_memory(metric, generators, Project()):
        
        self.project.info('Getting counts...')
        counts = self.construct_counts_matrix(assignments)
        
        return MarkovModel(counts=counts, assignments=assignments, distances=distances,
            forcefield=forcefield, trajectories=forcefield.trajectories)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    def load_trajs(self, ff_name, stride=1):
        """Load all the lh5 trajectories in traj_log that come from this forcefield
        
        Returns two lists, one of the trajectories, and one of their paths"""
        
        trajs = [t for t in self.project.traj_log if t['ff'] == ff_name]
        index_and_path = [(t['lh5_trajnum'], t['lh5_fn']) for t in trajs]
        
        loaded_trajs = [None] * len(trajs)
        sorted_paths = [None] * len(trajs)
        
        for index, path in index_and_path:
            try:
                t = Trajectory.LoadTrajectoryFile(path)
            except Exception as ex:
                a = '\n' + ''.join(['#'] * 80)
                b = a + '\nTrajectory ({path}) could not be loaded from lh5. It may be corrupt'.format(path=path)
                e = b + a
                raise IOError(str(ex) + e)
            loaded_trajs[index] = t[::stride]
            sorted_paths[index] = path
        
        return loaded_trajs, sorted_paths

    def run_round(self, checkdata=True):
        """This is the method that activates the builder, which eventually
        produces all the necessary MSM data for the Brain to make an
        informed decision about what/where to sample.
           
        (1) Checks to see if there is enough data around to warrant building a
            new set of MSMs 
        (2) Assuming yes, builds a new MSM in each FF, and a combined data MSM
        (3) Generates cross-assigned MSMs
        
        Args:    'checkdata' can be used to overrule the checking process
        Returns: True if actually did a round, False otherwise
        """
        
        if checkdata:
            self.logger.info("Checking if sufficient data has been acquired.")
            FF_to_build = self.is_sufficient_new_data()
            if FF_to_build is None:
                self.logger.info("No need to build a new MSM at this point.")
                return False
        else:
            self.logger.info("Skipping check for adequate data. Building MSMs for all forcefields.")
            FF_to_build = self.project.forcefields
                
        for FF in FF_to_build:
            self.logger.info("Building MSM for forcefield: {0}.".format(FF['name']))
            self.build_msm(FF)
        
        self.logger.info("Finished round: %d" % self.round_num)
        self.round_num += 1
        return True
    
    
    
    def build_msm(self, ff_dict):
        """Build an MSM according to the user-specified parameters, which are
        passed implicitly via the perviously parsed configuration YAML file.
        FF is the forcefield (a dict) to build the msm for"""
            
        self.logger.info("Building MSM for: %s" % FF['name'])
        
        # load trajectories
        trajs, paths = self.load_trajs(FF['name'], stride=self.project.stride)
        if len(trajs) == 0:
            raise IOError("Could not find any trajectories")
        
        self.logger.debug('Loaded trajectories. Clustering...')
        
        # the clustering algorithms are very verbose
        with open('/dev/null', 'w') as f:
            sys.stdout = f
            clusterer = self.project.clusterer(trajectories=trajs)
            sys.stdout = sys.__stdout__
        
        self.logger.debug('Assigning...')
        
        # assign this data to its generators
        if self.project.stride == 1:
            assignments = clusterer.get_assignments()
        else:
            # load up all the trajectories, no stride
            # note: if we start getting >10gigs of data this is going to be a memory issue,
            #       we could instead load up and cluster the trajs one at a time
            trajs, paths = self.load_trajs(FF['name'], stride=1)
            assignments = clusterer.assign_new_trajectories(trajs)
        
        self.logger.debug('Constructing counts matrix...')

        # Build an MSM
        counts = self.construct_counts_matrix(assignments)
        self.logger.debug('Got counts. Saving to disk...')
        
        # write output to disk
        self.logger.debug('Saving {a}'.format(a=self.project.assignments_fn(FF['name'], self.round_num)))
        Serializer.SaveData(self.project.assignments_fn(FF['name'], self.round_num),
                            assignments)
        io.mmwrite(self.project.counts_fn(FF['name'], self.round_num), counts)
        
        try:
            medoids = clusterer.get_generators_as_traj()
            medoids.SaveToLHDF(self.project.medoids_fn(FF['name'], self.round_num))
        except AttributeError as e:
            self.logger.warning(e.message)
        
        log_entry = {'forcefield': FF,
                     'round_num': self.round_num,
                     'lh5_fns': paths,
                     'total_num_frames': sum([len(t) for t in trajs])}
        self.project.builder_log_add(log_entry)
        
        self.logger.info('Built MSM sucessfully')


    def construct_counts_matrix(self, assignments):
        """Build and return a counts matrix from assignments. Symmetrize either
        with transpose or MLE based on the value of the self.symmetrize variable
        
        Also modifies the assignments file that you pass it to reflect ergodic
        trimming"""
        
        num_states  = np.max(assignments.flatten()) + 1
        raw_counts = GetCountMatrixFromAssignments(assignments, num_states,
                                            LagTime=self.project.lagtime, Slide=True)
        
        ergodic_counts = None
        if self.project.trim:
            try:
                ergodic_counts, mapping = ErgodicTrim(raw_counts)
                ApplyMappingToAssignments(assignments, mapping)
                counts = ergodic_counts
            except Exception as e:
                self.logger.warning("ErgodicTrim failed with message '{0}'".format(e))
        else:
            self.logger.info("Ignoring ergodic trimming")
            counts = raw_counts
        
        if self.project.symmetrize == 'transpose':
            self.logger.debug('Transpose symmetrizing')
            counts = counts + counts.T
        elif self.project.symmetrize == 'mle':
            self.logger.debug('MLE symmetrizing')
            counts = EstimateReversibleCountMatrix(counts)
        elif self.project.symmetrize == 'none' or self.project.symmetrize == None:
            self.logger.debug('Skipping symmetrization')
        else:
            raise ValueError("Could not understand symmetrization method: %s" % self.project.symmetrize)
        
        return counts
    

def test():
    os.system('rm -r /home/rmcgibbo/monakos/robert/project/amber99sb-ildn/round0')
    os.system('rm -r /home/rmcgibbo/monakos/robert/project/AllFF/round0')
    b = Builder('/home/rmcgibbo/monakos/robert/project',
            '/home/rmcgibbo/monakos/robert/MonakosParams.yaml')
            
    b.run_round()
    
if __name__ == '__main__':
    #test()
    pass
    
