import sys, os
import re
import numpy as np
from scipy import io
import logging

# msmbuilder imports
from msmbuilder.MSMLib import GetCountMatrixFromAssignments
from msmbuilder.MSMLib import EstimateReversibleCountMatrix
from msmbuilder.MSMLib import ErgodicTrim, ApplyMappingToAssignments
from msmbuilder import clustering, metrics
import msmbuilder.Trajectory
import msmbuilder.Serializer
from msmbuilder.assigning import assign_in_memory

from models import Trajectory, Forcefield, MarkovModel, MSMGroup
from database import Session

class Builder(object):
    """
    The Builder class is responsable for managing the construction of MSMs.
    it takes in the data generated by the QMaster and adds it to the database
    """
    
    def __init__(self, project):
        self.project = project
        self.logger = logging.getLogger('MSMAccelerator.Builder')
    
    @property
    def n_rounds(self):
        return Session.query(MSMGroup).count()
        
    def is_sufficient_new_data(self):
        """Is there sufficient new data to build a new round?
        
        Returns
        -------
        truth : boolean
            True if there is sufficient new data for a new round
        """
        
        # get most recent set of MSMs built
        msmgroup = Session.query(MSMGroup).order_by(MSMGroup.id.desc()).first()
        
        # the number of unique trajectories that are part of this msmgroup
        # by constructing a query for the union of trajectories in any of the msms
        # in the msm group
        q = Session.query(Trajectory)
        for msm in msmgroup.markov_models:
            q.union(Session.query(Trajectory).filter(Trajectory.markov_models.contains(msm)))
        n_built = q.count()
        
        # number of trajs in the database
        n_total = Session.query(Trajectory).count()
        
        truth = n_built + self.project.num_trajs_sufficient_for_round > n_total
        
        self.logger.info("{} trajs total, {} trajs built".format(n_total, n_built))
        return truth
    
    
    def run_round(self, checkdata=True):
        """Activate the builder and build new MSMs (if necessary)
        
        First, check to see if there is enough data are to warrant building a
        new set of MSMs. Assuming yes, do a joint clustering over all of the
        data, and then build MSMs for each forcefield on that state space.
        
        Parameters
        ----------
        checkdata : boolean, optional
            If False, skip the checking process
        
        Returns
        -------
        happened : boolean
            True if we actually did a round of MSM building, False otherwise
        """
        
        if checkdata:
            self.logger.info("Checking if sufficient data has been acquired.")
            if not self.is_sufficient_new_data():
                return False
        
        self.logger.info("Skipping check for adequate data.")
        
        # use all the data together to get the cluster centers
        generators = self.joint_clustering()
        
        msmgroup = MSMGroup()
        for msm in Session.query(Forcefields).all():
            msm = self.build_msm(forcefield, generators=generators)
            msmgroup.markov_models.append(msm)
        
        Session.add(msmgroup)
        Session.flush()
        self.logger.info("Round completed sucessfully")
        
        return True
        
        
    def joint_clustering(self):
        """Jointly cluster the the data from all of the forcefields
        
        Returns
        -------
        generators : msmbuilder.Trajectory
        """
        self.logger.info('Running joint clustering')
        
        # load up all the trajs in the database
        db_trajs = Session.query(Trajectories).all()
        
        # load the xyz coordinates from disk for each trajectory
        loaded_trjs = [t.load_from_lh5(self.project.stride) for q in db_trajs]
        
        clusterer = self.project.clusterer(trajectories=loaded_trjs)
        return clusterer.get_generators_as_traj()

            
    def build_msm(self, forcefield, generators):
        """Build an MSM for this forcefield using the most recent trajectories
        in the database.
        
        If supplied, use the supplied generators
        
        Parameters
        ----------
        forcefield : models.Forcefield
            database entry on the forcefield that we build for
        generators : msmbuilder.Trajectory

        Returns
        -------
        msm : models.MarkovModel
        
        """
        
        # I want to use assign_in_memory, which requires an msmbuilder.Project
        # so, lets spoof it
        class Project(dict):
            def __init__(self):
                self['NumTrajs'] = len(forcefield.trajectories)
                self['TrajLengths'] = np.array([len(t) for t in forcefield.trajectories])
            
            def load_traj(self, trj_index):
                forcefield.trajectories[trj_index].load_from_lh5()
        
        self.project.info('Assigning...')
        assignments, distances = assign_in_memory(metric, generators, Project())
        
        self.project.info('Getting counts...')
        counts = self.construct_counts_matrix(assignments)
        
        return MarkovModel(counts=counts, assignments=assignments, distances=distances,
            forcefield=forcefield, trajectories=forcefield.trajectories)
            
        
        
    def construct_counts_matrix(self, assignments):
        """Build and return a counts matrix from assignments. Symmetrize either
        with transpose or MLE based on the value of the self.symmetrize variable
        
        Also modifies the assignments file that you pass it to reflect ergodic
        trimming"""
        
        n_states  = np.max(assignments.flatten()) + 1
        raw_counts = GetCountMatrixFromAssignments(assignments, n_states,
                                    LagTime=self.project.lagtime, Slide=True)
        
        ergodic_counts = None
        if self.project.trim:
            raise NotImplementedError(('Trimming is not yet supported because '
                'we need to keep track of the mapping from trimmed to '
                ' untrimmed states for joint clustering to be right'))
            try:
                ergodic_counts, mapping = ErgodicTrim(raw_counts)
                ApplyMappingToAssignments(assignments, mapping)
                counts = ergodic_counts
            except Exception as e:
                self.logger.warning("ErgodicTrim failed with message '{0}'".format(e))
        else:
            self.logger.info("Ignoring ergodic trimming")
            counts = raw_counts
        
        if self.project.symmetrize == 'transpose':
            self.logger.debug('Transpose symmetrizing')
            counts = counts + counts.T
        elif self.project.symmetrize == 'mle':
            self.logger.debug('MLE symmetrizing')
            counts = EstimateReversibleCountMatrix(counts)
        elif self.project.symmetrize == 'none' or self.project.symmetrize == None:
            self.logger.debug('Skipping symmetrization')
        else:
            raise ValueError("Could not understand symmetrization method: %s" % self.project.symmetrize)
        
        return counts

